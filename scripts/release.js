const path = require("path");
const child_process = require("child_process");
const fs = require("fs");
const os = require("os");
const https = require("https");
const http = require("http");
const url = require("url");
const zlib = require("zlib");

const packages = {
    "makecode-core": {
        name: "makecode-core",
        aliases: ["core", "c"]
    },
    "makecode-node": {
        name: "makecode",
        aliases: ["node", "n"]
    },
    "makecode-browser": {
        name: "makecode-browser",
        aliases: ["browser", "b"]
    }
};

const args = process.argv.slice(2);
const root = path.resolve(__dirname, "..");

const commandArg = args[0].toLowerCase();

if (commandArg === "bump") {
    bump(getPackageDirectory(args[1].toLowerCase()), (args[2] || "patch").toLowerCase());
}
else if (commandArg === "publish") {
    publish();
}
else {
    console.error("Invalid command");
    printUsage();
    process.exit(1);
}

async function bump(packageDirectory, versionType) {
    if (!isWorkingDirectoryClean()) {
        console.error("Working git directory not clean. Aborting");
        process.exit(1);
    }

    const versionTypes = ["patch", "minor", "major"];
    if (versionType && versionTypes.indexOf(versionType) === -1) {
        console.error("Invalid version type");
        printUsage();
        process.exit(1);
    }

    const token = await getGitHubTokenAsync();

    exec("git fetch origin master", root);
    exec("git checkout master", root);
    exec("git merge origin/master --ff-only", root);
    const branchName = `release/${timestamp()}`;
    exec(`git checkout -b ${branchName}`, root);
    exec("npm version " + versionType + " --git-tag-version false", packageDirectory);

    const jsonPath = path.join(packageDirectory, "package.json");
    const json = JSON.parse(fs.readFileSync(jsonPath, "utf-8"));
    const version = json.version;
    const packageName = json.name;

    const tagName = `${packageName}-v${version}`;

    await spawnWithPipeAsync({
        cmd: "git",
        args: ["commit", "-am", `[release] bump version to ${tagName}`],
    });

    exec(`git push origin ${branchName}`, root);

    const url = await createPullRequestAsync({
        title: `[release] bump version to ${tagName}`,
        body:   "__Do not edit the PR title.__\n" +
                "It was automatically generated by `node ./scripts/release.js bump` and must follow a specific pattern.\n" +
                "GitHub workflows rely on it to trigger version tagging and publishing to npm.",
        head: branchName,
        base: "master",
        token,
        owner: "microsoft",
        repo: "pxt-mkc",
    });

    exec(`git checkout master`);
    console.log(`Pull request created: ${url}`);
}

function publish() {
    if (process.env.CI !== "true") {
        console.error("This command is only meant to be run in GitHub Actions");
        process.exit(0);
    }

    const commitMessage = process.env.COMMIT_MESSAGE?.trim();
    const match = /^\[release\] bump version to (makecode-core|makecode-browser|makecode)-v[0-9]+\.[0-9]+\.[0-9]+$/.exec(commitMessage);

    if (!match) {
        console.error("Not a release tag. Aborting");
        process.exit(0);
    }
    const packageName = match[1];

    console.log(`Publishing package: ${packageName}`);
    const packageDirectory = getPackageDirectory(packageName);

    const npmToken = process.env.NPM_ACCESS_TOKEN;

    if (!npmToken) {
        console.error("NPM_ACCESS_TOKEN not set. Aborting.");
        process.exit(1);
    }

    const npmrcPath = path.join(process.env.HOME, ".npmrc")
    const npmrc = `//registry.npmjs.org/:_authToken=${npmToken}\n`;

    console.log(`Writing ${npmrcPath}`);
    fs.writeFileSync(npmrcPath, npmrc);

    exec("npm publish", packageDirectory);
}

function printUsage() {
    console.log(`usage: node scripts/release.js bump core|node|browser patch|minor|major`);
}

function exec(command, cwd) {
    console.log(`${command}`)
    const result = execCore(command, cwd);

    if (result.status) {
        process.exit(result.status);
    }
}

function execCore(command, cwd) {
    const args = command.split(" ");
    const result = child_process.spawnSync(args[0], args.slice(1), { cwd, stdio: "inherit" });

    return result;
}

function isWorkingDirectoryClean() {
    const result = execCore("git diff-index --quiet HEAD --", root);
    if (result.status) {
        return false;
    }
    return true;
}

function getPackageDirectory(name) {
    let packageDirectory;
    for (const key of Object.keys(packages)) {
        const info = packages[key];

        if (key === name || info.name === name || info.aliases.indexOf(name) !== -1) {
            packageDirectory = key;
            break;
        }
    }

    if (!packageDirectory) {
        console.error("Invalid package");
        printUsage();
        process.exit(1);
    }

    return path.join(root, "packages", packageDirectory);
}

function timestamp(date = new Date()) {
    const yyyy = date.getUTCFullYear();
    const mm = String(date.getUTCMonth() + 1).padStart(2, "0");
    const dd = String(date.getUTCDate()).padStart(2, "0");
    const hh = String(date.getUTCHours()).padStart(2, "0");
    const min = String(date.getUTCMinutes()).padStart(2, "0");
    const sec = String(date.getUTCSeconds()).padStart(2, "0");
    return `${yyyy}${mm}${dd}-${hh}${min}${sec}`;
}

function spawnWithPipeAsync(opts) {
    // https://nodejs.org/en/blog/vulnerability/april-2024-security-releases-2
    if (os.platform() === "win32" && typeof opts.shell === "undefined") opts.shell = true
    if (opts.pipe === undefined) opts.pipe = true
    let info = opts.cmd + " " + opts.args.join(" ")
    if (opts.cwd && opts.cwd != ".") info = "cd " + opts.cwd + "; " + info
    //console.log("[run] " + info) // uncomment for debugging, but it can potentially leak secrets so do not check in
    return new Promise((resolve, reject) => {
        let ch = child_process.spawn(opts.cmd, opts.args, {
            cwd: opts.cwd,
            env: opts.envOverrides ? extendEnv(process.env, opts.envOverrides) : process.env,
            stdio: opts.pipe ? [opts.input == null ? process.stdin : "pipe", "pipe", process.stderr] : "inherit",
            shell: opts.shell || false
        } )
        let bufs = []
        if (opts.pipe)
            ch.stdout.on('data', (buf) => {
                bufs.push(buf)
                if (!opts.silent) {
                    process.stdout.write(buf)
                }
            })
        ch.on('close', (code) => {
            if (code != 0 && !opts.allowNonZeroExit)
                reject(new Error("Exit code: " + code + " from " + info))
            resolve(Buffer.concat(bufs))
        });
        if (opts.input != null)
            ch.stdin.end(opts.input, "utf8")
    })
}

async function getGitHubTokenAsync() {
    const outputBuf = await spawnWithPipeAsync({
        cmd: "git",
        args: ["credential", "fill"],
        input: "protocol=https\nhost=github.com\n\n",
        silent: true
    });

    const output = outputBuf.toString("utf8").trim();
    const lines = output.split("\n");
    const creds = {};
    for (const line of lines) {
        const [key, ...rest] = line.split("=");
        creds[key] = rest.join("=");
    }

    if (creds.password) {
        return creds.password;
    } else {
        throw new Error("No GitHub credentials found via git credential helper.");
    }
}

function httpRequestCoreAsync(options) {
    let isHttps = false

    let u = url.parse(options.url)

    if (u.protocol == "https:") isHttps = true
    else if (u.protocol == "http:") isHttps = false
    else return Promise.reject("bad protocol: " + u.protocol)

    u.headers = options.headers || {}
    let data = options.data
    u.method = options.method || (data == null ? "GET" : "POST");

    let buf = null;

    u.headers["accept-encoding"] = "gzip"
    u.headers["user-agent"] = "PXT-CLI"

    let gzipContent = false

    if (data != null) {
        if (Buffer.isBuffer(data)) {
            buf = data;
        } else if (typeof data == "object") {
            buf = Buffer.from(JSON.stringify(data), "utf8")
            u.headers["content-type"] = "application/json; charset=utf8"
            if (options.allowGzipPost) gzipContent = true
        } else if (typeof data == "string") {
            buf = Buffer.from(data, "utf8")
            if (options.allowGzipPost) gzipContent = true
        } else {
            throw new Error("bad data")
        }
    }

    if (gzipContent) {
        buf = zlib.gzipSync(buf)
        u.headers['content-encoding'] = "gzip"
    }

    if (buf)
        u.headers['content-length'] = buf.length

    return new Promise((resolve, reject) => {
        const handleResponse = (res) => {
            let g = res;
            if (/gzip/.test(res.headers['content-encoding'])) {
                let tmp = zlib.createUnzip();
                res.pipe(tmp);
                g = tmp;
            }

            resolve(readResAsync(g).then(buf => {
                let text = null
                let json = null
                try {
                    text = buf.toString("utf8")
                    json = JSON.parse(text)
                } catch (e) {
                }
                let resp = {
                    statusCode: res.statusCode,
                    headers: res.headers,
                    buffer: buf,
                    text: text,
                    json: json,
                }
                return resp;
            }))
        };

        const req = isHttps ? https.request(u, handleResponse) : http.request(u, handleResponse);
        req.on('error', (err) => reject(err))
        req.end(buf)
    })
}

function readResAsync(g) {
    return new Promise((resolve, reject) => {
        let bufs = []
        g.on('data', (c) => {
            if (typeof c === "string")
                bufs.push(Buffer.from(c, "utf8"))
            else
                bufs.push(c)
        });

        g.on("error", (err) => reject(err))

        g.on('end', () => resolve(Buffer.concat(bufs)))
    })
}


async function createPullRequestAsync(opts) {
    const { token, owner, repo, title, head, base, body } = opts;
    const res = await httpRequestCoreAsync({
        url: `https://api.github.com/repos/${owner}/${repo}/pulls`,
        method: "POST",
        headers: {
            Authorization: `token ${token}`,
            "Accept": "application/vnd.github+json",
            "Content-Type": "application/json",
        },
        data: {
            title,
            head,
            base,
            body,
        },
    });

    if (res.statusCode !== 201) {
        throw new Error(`Failed to create pull request: ${res.statusCode} ${res.text}`);
    }

    const data = await res.json;
    return data.html_url;
}